// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
)

type AutocompleteResultResultType string

const (
	AutocompleteResultResultTypeAdditionalDocument AutocompleteResultResultType = "ADDITIONAL_DOCUMENT"
	AutocompleteResultResultTypeApp                AutocompleteResultResultType = "APP"
	AutocompleteResultResultTypeBrowserHistory     AutocompleteResultResultType = "BROWSER_HISTORY"
	AutocompleteResultResultTypeDatasource         AutocompleteResultResultType = "DATASOURCE"
	AutocompleteResultResultTypeDocument           AutocompleteResultResultType = "DOCUMENT"
	AutocompleteResultResultTypeEntity             AutocompleteResultResultType = "ENTITY"
	AutocompleteResultResultTypeGolink             AutocompleteResultResultType = "GOLINK"
	AutocompleteResultResultTypeHistory            AutocompleteResultResultType = "HISTORY"
	AutocompleteResultResultTypeNewChat            AutocompleteResultResultType = "NEW_CHAT"
	AutocompleteResultResultTypeOperator           AutocompleteResultResultType = "OPERATOR"
	AutocompleteResultResultTypeOperatorValue      AutocompleteResultResultType = "OPERATOR_VALUE"
	AutocompleteResultResultTypeQuicklink          AutocompleteResultResultType = "QUICKLINK"
	AutocompleteResultResultTypeSuggestion         AutocompleteResultResultType = "SUGGESTION"
)

func (e AutocompleteResultResultType) ToPointer() *AutocompleteResultResultType {
	return &e
}
func (e *AutocompleteResultResultType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ADDITIONAL_DOCUMENT":
		fallthrough
	case "APP":
		fallthrough
	case "BROWSER_HISTORY":
		fallthrough
	case "DATASOURCE":
		fallthrough
	case "DOCUMENT":
		fallthrough
	case "ENTITY":
		fallthrough
	case "GOLINK":
		fallthrough
	case "HISTORY":
		fallthrough
	case "NEW_CHAT":
		fallthrough
	case "OPERATOR":
		fallthrough
	case "OPERATOR_VALUE":
		fallthrough
	case "QUICKLINK":
		fallthrough
	case "SUGGESTION":
		*e = AutocompleteResultResultType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AutocompleteResultResultType: %v", v)
	}
}

type AutocompleteResult struct {
	Result string `json:"result"`
	// A list of all possible keywords for given result.
	Keywords   []string                      `json:"keywords,omitempty"`
	ResultType *AutocompleteResultResultType `json:"resultType,omitempty"`
	// Higher indicates a more confident match.
	Score            *float64          `json:"score,omitempty"`
	OperatorMetadata *OperatorMetadata `json:"operatorMetadata,omitempty"`
	// An action for a specific datasource that will show up in autocomplete and app card, e.g. "Create new issue" for jira.
	Quicklink *Quicklink `json:"quicklink,omitempty"`
	Document  *Document  `json:"document,omitempty"`
	URL       *string    `json:"url,omitempty"`
	// A single object that can support any object in the work graph. Only a single object will be populated.
	StructuredResult *StructuredResult `json:"structuredResult,omitempty"`
	// A token to be passed in /feedback events associated with this autocomplete result.
	TrackingToken *string `json:"trackingToken,omitempty"`
	// Subsections of the result string to which some special formatting should be applied (eg. bold)
	Ranges []TextRange `json:"ranges,omitempty"`
}

func (o *AutocompleteResult) GetResult() string {
	if o == nil {
		return ""
	}
	return o.Result
}

func (o *AutocompleteResult) GetKeywords() []string {
	if o == nil {
		return nil
	}
	return o.Keywords
}

func (o *AutocompleteResult) GetResultType() *AutocompleteResultResultType {
	if o == nil {
		return nil
	}
	return o.ResultType
}

func (o *AutocompleteResult) GetScore() *float64 {
	if o == nil {
		return nil
	}
	return o.Score
}

func (o *AutocompleteResult) GetOperatorMetadata() *OperatorMetadata {
	if o == nil {
		return nil
	}
	return o.OperatorMetadata
}

func (o *AutocompleteResult) GetQuicklink() *Quicklink {
	if o == nil {
		return nil
	}
	return o.Quicklink
}

func (o *AutocompleteResult) GetDocument() *Document {
	if o == nil {
		return nil
	}
	return o.Document
}

func (o *AutocompleteResult) GetURL() *string {
	if o == nil {
		return nil
	}
	return o.URL
}

func (o *AutocompleteResult) GetStructuredResult() *StructuredResult {
	if o == nil {
		return nil
	}
	return o.StructuredResult
}

func (o *AutocompleteResult) GetTrackingToken() *string {
	if o == nil {
		return nil
	}
	return o.TrackingToken
}

func (o *AutocompleteResult) GetRanges() []TextRange {
	if o == nil {
		return nil
	}
	return o.Ranges
}
