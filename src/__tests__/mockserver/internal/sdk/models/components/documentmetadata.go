// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"mockserver/internal/sdk/utils"
	"time"
)

type DocumentMetadata struct {
	Datasource *string `json:"datasource,omitempty"`
	// The datasource instance from which the document was extracted.
	DatasourceInstance *string `json:"datasourceInstance,omitempty"`
	// The type of the result. Interpretation is specific to each datasource. (e.g. for Jira issues, this is the issue type such as Bug or Feature Request).
	ObjectType *string `json:"objectType,omitempty"`
	// The name of the container (higher level parent, not direct parent) of the result. Interpretation is specific to each datasource (e.g. Channels for Slack, Project for Jira). cf. parentId
	Container *string `json:"container,omitempty"`
	// The Glean Document ID of the container. Uniquely identifies the container.
	ContainerID *string `json:"containerId,omitempty"`
	// The Glean Document ID of the super container. Super container represents a broader abstraction that contains many containers. For example, whereas container might refer to a folder, super container would refer to a drive.
	SuperContainerID *string `json:"superContainerId,omitempty"`
	// The id of the direct parent of the result. Interpretation is specific to each datasource (e.g. parent issue for Jira). cf. container
	ParentID *string `json:"parentId,omitempty"`
	MimeType *string `json:"mimeType,omitempty"`
	// The index-wide unique identifier.
	DocumentID *string `json:"documentId,omitempty"`
	// A unique identifier used to represent the document in any logging or feedback requests in place of documentId.
	LoggingID *string `json:"loggingId,omitempty"`
	// Hash of the Glean Document ID.
	DocumentIDHash *string    `json:"documentIdHash,omitempty"`
	CreateTime     *time.Time `json:"createTime,omitempty"`
	UpdateTime     *time.Time `json:"updateTime,omitempty"`
	Author         *Person    `json:"author,omitempty"`
	Owner          *Person    `json:"owner,omitempty"`
	// A list of people mentioned in the document.
	MentionedPeople []Person `json:"mentionedPeople,omitempty"`
	// The level of visibility of the document as understood by our system.
	Visibility *DocumentVisibility `json:"visibility,omitempty"`
	// A list of components this result is associated with. Interpretation is specific to each datasource. (e.g. for Jira issues, these are [components](https://confluence.atlassian.com/jirasoftwarecloud/organizing-work-with-components-764478279.html).)
	Components []string `json:"components,omitempty"`
	// The status or disposition of the result. Interpretation is specific to each datasource. (e.g. for Jira issues, this is the issue status such as Done, In Progress or Will Not Fix).
	Status *string `json:"status,omitempty"`
	// The status category of the result. Meant to be more general than status. Interpretation is specific to each datasource.
	StatusCategory *string `json:"statusCategory,omitempty"`
	// A list of stars associated with this result.  "Pin" is an older name.
	Pins []PinDocument `json:"pins,omitempty"`
	// The document priority. Interpretation is datasource specific.
	Priority   *string `json:"priority,omitempty"`
	AssignedTo *Person `json:"assignedTo,omitempty"`
	UpdatedBy  *Person `json:"updatedBy,omitempty"`
	// A list of tags for the document. Interpretation is datasource specific.
	Labels []string `json:"labels,omitempty"`
	// A list of collections that the document belongs to.
	Collections []Collection `json:"collections,omitempty"`
	// The user-visible datasource specific id (e.g. Salesforce case number for example, GitHub PR number).
	DatasourceID *string               `json:"datasourceId,omitempty"`
	Interactions *DocumentInteractions `json:"interactions,omitempty"`
	Verification *Verification         `json:"verification,omitempty"`
	ViewerInfo   *ViewerInfo           `json:"viewerInfo,omitempty"`
	Permissions  *ObjectPermissions    `json:"permissions,omitempty"`
	VisitCount   *CountInfo            `json:"visitCount,omitempty"`
	// A list of shortcuts of which destination URL is for the document.
	Shortcuts []Shortcut `json:"shortcuts,omitempty"`
	// For file datasources like onedrive/github etc this has the path to the file
	Path *string `json:"path,omitempty"`
	// Custom fields specific to individual datasources
	CustomData map[string]CustomDataValue `json:"customData,omitempty"`
	// The document's document_category(.proto).
	DocumentCategory *string      `json:"documentCategory,omitempty"`
	ContactPerson    *Person      `json:"contactPerson,omitempty"`
	Thumbnail        *Thumbnail   `json:"thumbnail,omitempty"`
	IndexStatus      *IndexStatus `json:"indexStatus,omitempty"`
	// A list of documents that are ancestors of this document in the hierarchy of the document's datasource, for example parent folders or containers. Ancestors can be of different types and some may not be indexed. Higher level ancestors appear earlier in the list.
	Ancestors []Document `json:"ancestors,omitempty"`
}

func (d DocumentMetadata) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DocumentMetadata) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *DocumentMetadata) GetDatasource() *string {
	if o == nil {
		return nil
	}
	return o.Datasource
}

func (o *DocumentMetadata) GetDatasourceInstance() *string {
	if o == nil {
		return nil
	}
	return o.DatasourceInstance
}

func (o *DocumentMetadata) GetObjectType() *string {
	if o == nil {
		return nil
	}
	return o.ObjectType
}

func (o *DocumentMetadata) GetContainer() *string {
	if o == nil {
		return nil
	}
	return o.Container
}

func (o *DocumentMetadata) GetContainerID() *string {
	if o == nil {
		return nil
	}
	return o.ContainerID
}

func (o *DocumentMetadata) GetSuperContainerID() *string {
	if o == nil {
		return nil
	}
	return o.SuperContainerID
}

func (o *DocumentMetadata) GetParentID() *string {
	if o == nil {
		return nil
	}
	return o.ParentID
}

func (o *DocumentMetadata) GetMimeType() *string {
	if o == nil {
		return nil
	}
	return o.MimeType
}

func (o *DocumentMetadata) GetDocumentID() *string {
	if o == nil {
		return nil
	}
	return o.DocumentID
}

func (o *DocumentMetadata) GetLoggingID() *string {
	if o == nil {
		return nil
	}
	return o.LoggingID
}

func (o *DocumentMetadata) GetDocumentIDHash() *string {
	if o == nil {
		return nil
	}
	return o.DocumentIDHash
}

func (o *DocumentMetadata) GetCreateTime() *time.Time {
	if o == nil {
		return nil
	}
	return o.CreateTime
}

func (o *DocumentMetadata) GetUpdateTime() *time.Time {
	if o == nil {
		return nil
	}
	return o.UpdateTime
}

func (o *DocumentMetadata) GetAuthor() *Person {
	if o == nil {
		return nil
	}
	return o.Author
}

func (o *DocumentMetadata) GetOwner() *Person {
	if o == nil {
		return nil
	}
	return o.Owner
}

func (o *DocumentMetadata) GetMentionedPeople() []Person {
	if o == nil {
		return nil
	}
	return o.MentionedPeople
}

func (o *DocumentMetadata) GetVisibility() *DocumentVisibility {
	if o == nil {
		return nil
	}
	return o.Visibility
}

func (o *DocumentMetadata) GetComponents() []string {
	if o == nil {
		return nil
	}
	return o.Components
}

func (o *DocumentMetadata) GetStatus() *string {
	if o == nil {
		return nil
	}
	return o.Status
}

func (o *DocumentMetadata) GetStatusCategory() *string {
	if o == nil {
		return nil
	}
	return o.StatusCategory
}

func (o *DocumentMetadata) GetPins() []PinDocument {
	if o == nil {
		return nil
	}
	return o.Pins
}

func (o *DocumentMetadata) GetPriority() *string {
	if o == nil {
		return nil
	}
	return o.Priority
}

func (o *DocumentMetadata) GetAssignedTo() *Person {
	if o == nil {
		return nil
	}
	return o.AssignedTo
}

func (o *DocumentMetadata) GetUpdatedBy() *Person {
	if o == nil {
		return nil
	}
	return o.UpdatedBy
}

func (o *DocumentMetadata) GetLabels() []string {
	if o == nil {
		return nil
	}
	return o.Labels
}

func (o *DocumentMetadata) GetCollections() []Collection {
	if o == nil {
		return nil
	}
	return o.Collections
}

func (o *DocumentMetadata) GetDatasourceID() *string {
	if o == nil {
		return nil
	}
	return o.DatasourceID
}

func (o *DocumentMetadata) GetInteractions() *DocumentInteractions {
	if o == nil {
		return nil
	}
	return o.Interactions
}

func (o *DocumentMetadata) GetVerification() *Verification {
	if o == nil {
		return nil
	}
	return o.Verification
}

func (o *DocumentMetadata) GetViewerInfo() *ViewerInfo {
	if o == nil {
		return nil
	}
	return o.ViewerInfo
}

func (o *DocumentMetadata) GetPermissions() *ObjectPermissions {
	if o == nil {
		return nil
	}
	return o.Permissions
}

func (o *DocumentMetadata) GetVisitCount() *CountInfo {
	if o == nil {
		return nil
	}
	return o.VisitCount
}

func (o *DocumentMetadata) GetShortcuts() []Shortcut {
	if o == nil {
		return nil
	}
	return o.Shortcuts
}

func (o *DocumentMetadata) GetPath() *string {
	if o == nil {
		return nil
	}
	return o.Path
}

func (o *DocumentMetadata) GetCustomData() map[string]CustomDataValue {
	if o == nil {
		return nil
	}
	return o.CustomData
}

func (o *DocumentMetadata) GetDocumentCategory() *string {
	if o == nil {
		return nil
	}
	return o.DocumentCategory
}

func (o *DocumentMetadata) GetContactPerson() *Person {
	if o == nil {
		return nil
	}
	return o.ContactPerson
}

func (o *DocumentMetadata) GetThumbnail() *Thumbnail {
	if o == nil {
		return nil
	}
	return o.Thumbnail
}

func (o *DocumentMetadata) GetIndexStatus() *IndexStatus {
	if o == nil {
		return nil
	}
	return o.IndexStatus
}

func (o *DocumentMetadata) GetAncestors() []Document {
	if o == nil {
		return nil
	}
	return o.Ancestors
}
