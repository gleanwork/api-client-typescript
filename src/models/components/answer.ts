/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  AnswerBoard,
  AnswerBoard$inboundSchema,
  AnswerBoard$Outbound,
  AnswerBoard$outboundSchema,
} from "./answerboard.js";
import {
  AnswerLikes,
  AnswerLikes$inboundSchema,
  AnswerLikes$Outbound,
  AnswerLikes$outboundSchema,
} from "./answerlikes.js";
import {
  Collection,
  Collection$inboundSchema,
  Collection$Outbound,
  Collection$outboundSchema,
} from "./collection.js";
import {
  Document,
  Document$inboundSchema,
  Document$Outbound,
  Document$outboundSchema,
} from "./document.js";
import {
  DocumentSpecUnion,
  DocumentSpecUnion$inboundSchema,
  DocumentSpecUnion$Outbound,
  DocumentSpecUnion$outboundSchema,
} from "./documentspecunion.js";
import {
  FacetFilter,
  FacetFilter$inboundSchema,
  FacetFilter$Outbound,
  FacetFilter$outboundSchema,
} from "./facetfilter.js";
import {
  ObjectPermissions,
  ObjectPermissions$inboundSchema,
  ObjectPermissions$Outbound,
  ObjectPermissions$outboundSchema,
} from "./objectpermissions.js";
import {
  Person,
  Person$inboundSchema,
  Person$Outbound,
  Person$outboundSchema,
} from "./person.js";
import {
  StructuredText,
  StructuredText$inboundSchema,
  StructuredText$Outbound,
  StructuredText$outboundSchema,
} from "./structuredtext.js";
import {
  UserRoleSpecification,
  UserRoleSpecification$inboundSchema,
  UserRoleSpecification$Outbound,
  UserRoleSpecification$outboundSchema,
} from "./userrolespecification.js";
import {
  Verification,
  Verification$inboundSchema,
  Verification$Outbound,
  Verification$outboundSchema,
} from "./verification.js";

export const AnswerSourceType = {
  Document: "DOCUMENT",
  Assistant: "ASSISTANT",
} as const;
export type AnswerSourceType = ClosedEnum<typeof AnswerSourceType>;

export type Answer = {
  /**
   * The opaque ID of the Answer.
   */
  id: number;
  /**
   * Glean Document ID of the Answer. The Glean Document ID is supported for cases where the Answer ID isn't available. If both are available, using the Answer ID is preferred.
   */
  docId?: string | undefined;
  question?: string | undefined;
  /**
   * Additional ways of phrasing this question.
   */
  questionVariations?: Array<string> | undefined;
  /**
   * The plain text answer to the question.
   */
  bodyText?: string | undefined;
  /**
   * The parent board ID of this Answer, or 0 if it's a floating Answer.
   */
  boardId?: number | undefined;
  /**
   * Filters which restrict who should see the answer. Values are taken from the corresponding filters in people search.
   */
  audienceFilters?: Array<FacetFilter> | undefined;
  /**
   * A list of user roles for the answer added by the owner.
   */
  addedRoles?: Array<UserRoleSpecification> | undefined;
  /**
   * A list of user roles for the answer removed by the owner.
   */
  removedRoles?: Array<UserRoleSpecification> | undefined;
  /**
   * A list of roles for this answer explicitly granted by an owner, editor, or admin.
   */
  roles?: Array<UserRoleSpecification> | undefined;
  sourceDocumentSpec?: DocumentSpecUnion | undefined;
  sourceType?: AnswerSourceType | undefined;
  permissions?: ObjectPermissions | undefined;
  combinedAnswerText?: StructuredText | undefined;
  likes?: AnswerLikes | undefined;
  author?: Person | undefined;
  /**
   * The time the answer was created in ISO format (ISO 8601).
   */
  createTime?: Date | undefined;
  /**
   * The time the answer was last updated in ISO format (ISO 8601).
   */
  updateTime?: Date | undefined;
  updatedBy?: Person | undefined;
  verification?: Verification | undefined;
  board?: AnswerBoard | undefined;
  /**
   * The collections to which the answer belongs.
   */
  collections?: Array<Collection> | undefined;
  /**
   * The document's document_category(.proto).
   */
  documentCategory?: string | undefined;
  sourceDocument?: Document | undefined;
};

/** @internal */
export const AnswerSourceType$inboundSchema: z.ZodNativeEnum<
  typeof AnswerSourceType
> = z.nativeEnum(AnswerSourceType);

/** @internal */
export const AnswerSourceType$outboundSchema: z.ZodNativeEnum<
  typeof AnswerSourceType
> = AnswerSourceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AnswerSourceType$ {
  /** @deprecated use `AnswerSourceType$inboundSchema` instead. */
  export const inboundSchema = AnswerSourceType$inboundSchema;
  /** @deprecated use `AnswerSourceType$outboundSchema` instead. */
  export const outboundSchema = AnswerSourceType$outboundSchema;
}

/** @internal */
export const Answer$inboundSchema: z.ZodType<Answer, z.ZodTypeDef, unknown> = z
  .object({
    id: z.number().int(),
    docId: z.string().optional(),
    question: z.string().optional(),
    questionVariations: z.array(z.string()).optional(),
    bodyText: z.string().optional(),
    boardId: z.number().int().optional(),
    audienceFilters: z.array(FacetFilter$inboundSchema).optional(),
    addedRoles: z.array(z.lazy(() => UserRoleSpecification$inboundSchema))
      .optional(),
    removedRoles: z.array(z.lazy(() => UserRoleSpecification$inboundSchema))
      .optional(),
    roles: z.array(z.lazy(() => UserRoleSpecification$inboundSchema))
      .optional(),
    sourceDocumentSpec: DocumentSpecUnion$inboundSchema.optional(),
    sourceType: AnswerSourceType$inboundSchema.optional(),
    permissions: ObjectPermissions$inboundSchema.optional(),
    combinedAnswerText: z.lazy(() => StructuredText$inboundSchema).optional(),
    likes: z.lazy(() => AnswerLikes$inboundSchema).optional(),
    author: z.lazy(() => Person$inboundSchema).optional(),
    createTime: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ).optional(),
    updateTime: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ).optional(),
    updatedBy: z.lazy(() => Person$inboundSchema).optional(),
    verification: z.lazy(() => Verification$inboundSchema).optional(),
    board: z.lazy(() => AnswerBoard$inboundSchema).optional(),
    collections: z.array(z.lazy(() => Collection$inboundSchema)).optional(),
    documentCategory: z.string().optional(),
    sourceDocument: z.lazy(() => Document$inboundSchema).optional(),
  });

/** @internal */
export type Answer$Outbound = {
  id: number;
  docId?: string | undefined;
  question?: string | undefined;
  questionVariations?: Array<string> | undefined;
  bodyText?: string | undefined;
  boardId?: number | undefined;
  audienceFilters?: Array<FacetFilter$Outbound> | undefined;
  addedRoles?: Array<UserRoleSpecification$Outbound> | undefined;
  removedRoles?: Array<UserRoleSpecification$Outbound> | undefined;
  roles?: Array<UserRoleSpecification$Outbound> | undefined;
  sourceDocumentSpec?: DocumentSpecUnion$Outbound | undefined;
  sourceType?: string | undefined;
  permissions?: ObjectPermissions$Outbound | undefined;
  combinedAnswerText?: StructuredText$Outbound | undefined;
  likes?: AnswerLikes$Outbound | undefined;
  author?: Person$Outbound | undefined;
  createTime?: string | undefined;
  updateTime?: string | undefined;
  updatedBy?: Person$Outbound | undefined;
  verification?: Verification$Outbound | undefined;
  board?: AnswerBoard$Outbound | undefined;
  collections?: Array<Collection$Outbound> | undefined;
  documentCategory?: string | undefined;
  sourceDocument?: Document$Outbound | undefined;
};

/** @internal */
export const Answer$outboundSchema: z.ZodType<
  Answer$Outbound,
  z.ZodTypeDef,
  Answer
> = z.object({
  id: z.number().int(),
  docId: z.string().optional(),
  question: z.string().optional(),
  questionVariations: z.array(z.string()).optional(),
  bodyText: z.string().optional(),
  boardId: z.number().int().optional(),
  audienceFilters: z.array(FacetFilter$outboundSchema).optional(),
  addedRoles: z.array(z.lazy(() => UserRoleSpecification$outboundSchema))
    .optional(),
  removedRoles: z.array(z.lazy(() => UserRoleSpecification$outboundSchema))
    .optional(),
  roles: z.array(z.lazy(() => UserRoleSpecification$outboundSchema)).optional(),
  sourceDocumentSpec: DocumentSpecUnion$outboundSchema.optional(),
  sourceType: AnswerSourceType$outboundSchema.optional(),
  permissions: ObjectPermissions$outboundSchema.optional(),
  combinedAnswerText: z.lazy(() => StructuredText$outboundSchema).optional(),
  likes: z.lazy(() => AnswerLikes$outboundSchema).optional(),
  author: z.lazy(() => Person$outboundSchema).optional(),
  createTime: z.date().transform(v => v.toISOString()).optional(),
  updateTime: z.date().transform(v => v.toISOString()).optional(),
  updatedBy: z.lazy(() => Person$outboundSchema).optional(),
  verification: z.lazy(() => Verification$outboundSchema).optional(),
  board: z.lazy(() => AnswerBoard$outboundSchema).optional(),
  collections: z.array(z.lazy(() => Collection$outboundSchema)).optional(),
  documentCategory: z.string().optional(),
  sourceDocument: z.lazy(() => Document$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Answer$ {
  /** @deprecated use `Answer$inboundSchema` instead. */
  export const inboundSchema = Answer$inboundSchema;
  /** @deprecated use `Answer$outboundSchema` instead. */
  export const outboundSchema = Answer$outboundSchema;
  /** @deprecated use `Answer$Outbound` instead. */
  export type Outbound = Answer$Outbound;
}

export function answerToJSON(answer: Answer): string {
  return JSON.stringify(Answer$outboundSchema.parse(answer));
}

export function answerFromJSON(
  jsonString: string,
): SafeParseResult<Answer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Answer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Answer' from JSON`,
  );
}
