/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  Collection,
  Collection$inboundSchema,
  Collection$Outbound,
  Collection$outboundSchema,
} from "./collection.js";
import {
  CountInfo,
  CountInfo$inboundSchema,
  CountInfo$Outbound,
  CountInfo$outboundSchema,
} from "./countinfo.js";
import {
  CustomDataValue,
  CustomDataValue$inboundSchema,
  CustomDataValue$Outbound,
  CustomDataValue$outboundSchema,
} from "./customdatavalue.js";
import {
  Document,
  Document$inboundSchema,
  Document$Outbound,
  Document$outboundSchema,
} from "./document.js";
import {
  DocumentInteractions,
  DocumentInteractions$inboundSchema,
  DocumentInteractions$Outbound,
  DocumentInteractions$outboundSchema,
} from "./documentinteractions.js";
import {
  DocumentVisibility,
  DocumentVisibility$inboundSchema,
  DocumentVisibility$outboundSchema,
} from "./documentvisibility.js";
import {
  IndexStatus,
  IndexStatus$inboundSchema,
  IndexStatus$Outbound,
  IndexStatus$outboundSchema,
} from "./indexstatus.js";
import {
  ObjectPermissions,
  ObjectPermissions$inboundSchema,
  ObjectPermissions$Outbound,
  ObjectPermissions$outboundSchema,
} from "./objectpermissions.js";
import {
  Person,
  Person$inboundSchema,
  Person$Outbound,
  Person$outboundSchema,
} from "./person.js";
import {
  PinDocument,
  PinDocument$inboundSchema,
  PinDocument$Outbound,
  PinDocument$outboundSchema,
} from "./pindocument.js";
import {
  Shortcut,
  Shortcut$inboundSchema,
  Shortcut$Outbound,
  Shortcut$outboundSchema,
} from "./shortcut.js";
import {
  Thumbnail,
  Thumbnail$inboundSchema,
  Thumbnail$Outbound,
  Thumbnail$outboundSchema,
} from "./thumbnail.js";
import {
  Verification,
  Verification$inboundSchema,
  Verification$Outbound,
  Verification$outboundSchema,
} from "./verification.js";
import {
  ViewerInfo,
  ViewerInfo$inboundSchema,
  ViewerInfo$Outbound,
  ViewerInfo$outboundSchema,
} from "./viewerinfo.js";

export type DocumentMetadata = {
  datasource?: string | undefined;
  /**
   * The datasource instance from which the document was extracted.
   */
  datasourceInstance?: string | undefined;
  /**
   * The type of the result. Interpretation is specific to each datasource. (e.g. for Jira issues, this is the issue type such as Bug or Feature Request).
   */
  objectType?: string | undefined;
  /**
   * The name of the container (higher level parent, not direct parent) of the result. Interpretation is specific to each datasource (e.g. Channels for Slack, Project for Jira). cf. parentId
   */
  container?: string | undefined;
  /**
   * The Glean Document ID of the container. Uniquely identifies the container.
   */
  containerId?: string | undefined;
  /**
   * The Glean Document ID of the super container. Super container represents a broader abstraction that contains many containers. For example, whereas container might refer to a folder, super container would refer to a drive.
   */
  superContainerId?: string | undefined;
  /**
   * The id of the direct parent of the result. Interpretation is specific to each datasource (e.g. parent issue for Jira). cf. container
   */
  parentId?: string | undefined;
  mimeType?: string | undefined;
  /**
   * The index-wide unique identifier.
   */
  documentId?: string | undefined;
  /**
   * A unique identifier used to represent the document in any logging or feedback requests in place of documentId.
   */
  loggingId?: string | undefined;
  /**
   * Hash of the Glean Document ID.
   */
  documentIdHash?: string | undefined;
  createTime?: Date | undefined;
  updateTime?: Date | undefined;
  author?: Person | undefined;
  owner?: Person | undefined;
  /**
   * A list of people mentioned in the document.
   */
  mentionedPeople?: Array<Person> | undefined;
  /**
   * The level of visibility of the document as understood by our system.
   */
  visibility?: DocumentVisibility | undefined;
  /**
   * A list of components this result is associated with. Interpretation is specific to each datasource. (e.g. for Jira issues, these are [components](https://confluence.atlassian.com/jirasoftwarecloud/organizing-work-with-components-764478279.html).)
   */
  components?: Array<string> | undefined;
  /**
   * The status or disposition of the result. Interpretation is specific to each datasource. (e.g. for Jira issues, this is the issue status such as Done, In Progress or Will Not Fix).
   */
  status?: string | undefined;
  /**
   * The status category of the result. Meant to be more general than status. Interpretation is specific to each datasource.
   */
  statusCategory?: string | undefined;
  /**
   * A list of stars associated with this result.  "Pin" is an older name.
   */
  pins?: Array<PinDocument> | undefined;
  /**
   * The document priority. Interpretation is datasource specific.
   */
  priority?: string | undefined;
  assignedTo?: Person | undefined;
  updatedBy?: Person | undefined;
  /**
   * A list of tags for the document. Interpretation is datasource specific.
   */
  labels?: Array<string> | undefined;
  /**
   * A list of collections that the document belongs to.
   */
  collections?: Array<Collection> | undefined;
  /**
   * The user-visible datasource specific id (e.g. Salesforce case number for example, GitHub PR number).
   */
  datasourceId?: string | undefined;
  interactions?: DocumentInteractions | undefined;
  verification?: Verification | undefined;
  viewerInfo?: ViewerInfo | undefined;
  permissions?: ObjectPermissions | undefined;
  visitCount?: CountInfo | undefined;
  /**
   * A list of shortcuts of which destination URL is for the document.
   */
  shortcuts?: Array<Shortcut> | undefined;
  /**
   * For file datasources like onedrive/github etc this has the path to the file
   */
  path?: string | undefined;
  /**
   * Custom fields specific to individual datasources
   */
  customData?: { [k: string]: CustomDataValue } | undefined;
  /**
   * The document's document_category(.proto).
   */
  documentCategory?: string | undefined;
  contactPerson?: Person | undefined;
  thumbnail?: Thumbnail | undefined;
  indexStatus?: IndexStatus | undefined;
  /**
   * A list of documents that are ancestors of this document in the hierarchy of the document's datasource, for example parent folders or containers. Ancestors can be of different types and some may not be indexed. Higher level ancestors appear earlier in the list.
   */
  ancestors?: Array<Document> | undefined;
};

/** @internal */
export const DocumentMetadata$inboundSchema: z.ZodType<
  DocumentMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  datasource: z.string().optional(),
  datasourceInstance: z.string().optional(),
  objectType: z.string().optional(),
  container: z.string().optional(),
  containerId: z.string().optional(),
  superContainerId: z.string().optional(),
  parentId: z.string().optional(),
  mimeType: z.string().optional(),
  documentId: z.string().optional(),
  loggingId: z.string().optional(),
  documentIdHash: z.string().optional(),
  createTime: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  updateTime: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  author: z.lazy(() => Person$inboundSchema).optional(),
  owner: z.lazy(() => Person$inboundSchema).optional(),
  mentionedPeople: z.array(z.lazy(() => Person$inboundSchema)).optional(),
  visibility: DocumentVisibility$inboundSchema.optional(),
  components: z.array(z.string()).optional(),
  status: z.string().optional(),
  statusCategory: z.string().optional(),
  pins: z.array(z.lazy(() => PinDocument$inboundSchema)).optional(),
  priority: z.string().optional(),
  assignedTo: z.lazy(() => Person$inboundSchema).optional(),
  updatedBy: z.lazy(() => Person$inboundSchema).optional(),
  labels: z.array(z.string()).optional(),
  collections: z.array(z.lazy(() => Collection$inboundSchema)).optional(),
  datasourceId: z.string().optional(),
  interactions: z.lazy(() => DocumentInteractions$inboundSchema).optional(),
  verification: z.lazy(() => Verification$inboundSchema).optional(),
  viewerInfo: ViewerInfo$inboundSchema.optional(),
  permissions: ObjectPermissions$inboundSchema.optional(),
  visitCount: CountInfo$inboundSchema.optional(),
  shortcuts: z.array(Shortcut$inboundSchema).optional(),
  path: z.string().optional(),
  customData: z.record(CustomDataValue$inboundSchema).optional(),
  documentCategory: z.string().optional(),
  contactPerson: z.lazy(() => Person$inboundSchema).optional(),
  thumbnail: Thumbnail$inboundSchema.optional(),
  indexStatus: IndexStatus$inboundSchema.optional(),
  ancestors: z.array(z.lazy(() => Document$inboundSchema)).optional(),
});

/** @internal */
export type DocumentMetadata$Outbound = {
  datasource?: string | undefined;
  datasourceInstance?: string | undefined;
  objectType?: string | undefined;
  container?: string | undefined;
  containerId?: string | undefined;
  superContainerId?: string | undefined;
  parentId?: string | undefined;
  mimeType?: string | undefined;
  documentId?: string | undefined;
  loggingId?: string | undefined;
  documentIdHash?: string | undefined;
  createTime?: string | undefined;
  updateTime?: string | undefined;
  author?: Person$Outbound | undefined;
  owner?: Person$Outbound | undefined;
  mentionedPeople?: Array<Person$Outbound> | undefined;
  visibility?: string | undefined;
  components?: Array<string> | undefined;
  status?: string | undefined;
  statusCategory?: string | undefined;
  pins?: Array<PinDocument$Outbound> | undefined;
  priority?: string | undefined;
  assignedTo?: Person$Outbound | undefined;
  updatedBy?: Person$Outbound | undefined;
  labels?: Array<string> | undefined;
  collections?: Array<Collection$Outbound> | undefined;
  datasourceId?: string | undefined;
  interactions?: DocumentInteractions$Outbound | undefined;
  verification?: Verification$Outbound | undefined;
  viewerInfo?: ViewerInfo$Outbound | undefined;
  permissions?: ObjectPermissions$Outbound | undefined;
  visitCount?: CountInfo$Outbound | undefined;
  shortcuts?: Array<Shortcut$Outbound> | undefined;
  path?: string | undefined;
  customData?: { [k: string]: CustomDataValue$Outbound } | undefined;
  documentCategory?: string | undefined;
  contactPerson?: Person$Outbound | undefined;
  thumbnail?: Thumbnail$Outbound | undefined;
  indexStatus?: IndexStatus$Outbound | undefined;
  ancestors?: Array<Document$Outbound> | undefined;
};

/** @internal */
export const DocumentMetadata$outboundSchema: z.ZodType<
  DocumentMetadata$Outbound,
  z.ZodTypeDef,
  DocumentMetadata
> = z.object({
  datasource: z.string().optional(),
  datasourceInstance: z.string().optional(),
  objectType: z.string().optional(),
  container: z.string().optional(),
  containerId: z.string().optional(),
  superContainerId: z.string().optional(),
  parentId: z.string().optional(),
  mimeType: z.string().optional(),
  documentId: z.string().optional(),
  loggingId: z.string().optional(),
  documentIdHash: z.string().optional(),
  createTime: z.date().transform(v => v.toISOString()).optional(),
  updateTime: z.date().transform(v => v.toISOString()).optional(),
  author: z.lazy(() => Person$outboundSchema).optional(),
  owner: z.lazy(() => Person$outboundSchema).optional(),
  mentionedPeople: z.array(z.lazy(() => Person$outboundSchema)).optional(),
  visibility: DocumentVisibility$outboundSchema.optional(),
  components: z.array(z.string()).optional(),
  status: z.string().optional(),
  statusCategory: z.string().optional(),
  pins: z.array(z.lazy(() => PinDocument$outboundSchema)).optional(),
  priority: z.string().optional(),
  assignedTo: z.lazy(() => Person$outboundSchema).optional(),
  updatedBy: z.lazy(() => Person$outboundSchema).optional(),
  labels: z.array(z.string()).optional(),
  collections: z.array(z.lazy(() => Collection$outboundSchema)).optional(),
  datasourceId: z.string().optional(),
  interactions: z.lazy(() => DocumentInteractions$outboundSchema).optional(),
  verification: z.lazy(() => Verification$outboundSchema).optional(),
  viewerInfo: ViewerInfo$outboundSchema.optional(),
  permissions: ObjectPermissions$outboundSchema.optional(),
  visitCount: CountInfo$outboundSchema.optional(),
  shortcuts: z.array(Shortcut$outboundSchema).optional(),
  path: z.string().optional(),
  customData: z.record(CustomDataValue$outboundSchema).optional(),
  documentCategory: z.string().optional(),
  contactPerson: z.lazy(() => Person$outboundSchema).optional(),
  thumbnail: Thumbnail$outboundSchema.optional(),
  indexStatus: IndexStatus$outboundSchema.optional(),
  ancestors: z.array(z.lazy(() => Document$outboundSchema)).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DocumentMetadata$ {
  /** @deprecated use `DocumentMetadata$inboundSchema` instead. */
  export const inboundSchema = DocumentMetadata$inboundSchema;
  /** @deprecated use `DocumentMetadata$outboundSchema` instead. */
  export const outboundSchema = DocumentMetadata$outboundSchema;
  /** @deprecated use `DocumentMetadata$Outbound` instead. */
  export type Outbound = DocumentMetadata$Outbound;
}

export function documentMetadataToJSON(
  documentMetadata: DocumentMetadata,
): string {
  return JSON.stringify(
    DocumentMetadata$outboundSchema.parse(documentMetadata),
  );
}

export function documentMetadataFromJSON(
  jsonString: string,
): SafeParseResult<DocumentMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DocumentMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DocumentMetadata' from JSON`,
  );
}
