/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type UploadimageRequest = {
  /**
   * Email address of a user on whose behalf the request is intended to be made (should be non-empty only for global tokens).
   */
  xScioActas?: string | undefined;
  /**
   * Auth type being used to access the endpoint (should be non-empty only for global tokens).
   */
  xGleanAuthType?: string | undefined;
  /**
   * The type of image requested. Supported values are listed in ImageMetadata.type enum.
   */
  type?: components.ImageType | undefined;
  /**
   * ID, if a specific entity/type is requested. The id may have different meaning for each type. For USER, it is user id For UGC, it is the id of the content For ICON, the doctype.
   */
  id?: string | undefined;
  /**
   * A specific datasource for which an image is requested for. The ds may have different meaning for each type and can also be empty for some. For USER, it is empty or datasource the icon is asked for. For UGC, it is the UGC datasource. For ICON, it is datasource instance the icon is asked for.
   */
  ds?: string | undefined;
  /**
   * Content id to differentitate multiple images that can have the same type and datasource e.g. thumnail or image from content of UGC. It can also be empty.
   */
  cid?: string | undefined;
  /**
   * Content and metadata for the image. Content is in the POST body, metadata is in the URL.
   */
  requestBody: ReadableStream<Uint8Array> | Blob | ArrayBuffer | Uint8Array;
};

/** @internal */
export const UploadimageRequest$inboundSchema: z.ZodType<
  UploadimageRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  "X-Scio-Actas": z.string().optional(),
  "X-Glean-Auth-Type": z.string().optional(),
  type: components.ImageType$inboundSchema.optional(),
  id: z.string().optional(),
  ds: z.string().optional(),
  cid: z.string().optional(),
  RequestBody: z.union([
    z.instanceof(ReadableStream<Uint8Array>),
    z.instanceof(Blob),
    z.instanceof(ArrayBuffer),
    z.instanceof(Uint8Array),
  ]),
}).transform((v) => {
  return remap$(v, {
    "X-Scio-Actas": "xScioActas",
    "X-Glean-Auth-Type": "xGleanAuthType",
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type UploadimageRequest$Outbound = {
  "X-Scio-Actas"?: string | undefined;
  "X-Glean-Auth-Type"?: string | undefined;
  type?: string | undefined;
  id?: string | undefined;
  ds?: string | undefined;
  cid?: string | undefined;
  RequestBody: ReadableStream<Uint8Array> | Blob | ArrayBuffer | Uint8Array;
};

/** @internal */
export const UploadimageRequest$outboundSchema: z.ZodType<
  UploadimageRequest$Outbound,
  z.ZodTypeDef,
  UploadimageRequest
> = z.object({
  xScioActas: z.string().optional(),
  xGleanAuthType: z.string().optional(),
  type: components.ImageType$outboundSchema.optional(),
  id: z.string().optional(),
  ds: z.string().optional(),
  cid: z.string().optional(),
  requestBody: z.union([
    z.instanceof(ReadableStream<Uint8Array>),
    z.instanceof(Blob),
    z.instanceof(ArrayBuffer),
    z.instanceof(Uint8Array),
  ]),
}).transform((v) => {
  return remap$(v, {
    xScioActas: "X-Scio-Actas",
    xGleanAuthType: "X-Glean-Auth-Type",
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UploadimageRequest$ {
  /** @deprecated use `UploadimageRequest$inboundSchema` instead. */
  export const inboundSchema = UploadimageRequest$inboundSchema;
  /** @deprecated use `UploadimageRequest$outboundSchema` instead. */
  export const outboundSchema = UploadimageRequest$outboundSchema;
  /** @deprecated use `UploadimageRequest$Outbound` instead. */
  export type Outbound = UploadimageRequest$Outbound;
}

export function uploadimageRequestToJSON(
  uploadimageRequest: UploadimageRequest,
): string {
  return JSON.stringify(
    UploadimageRequest$outboundSchema.parse(uploadimageRequest),
  );
}

export function uploadimageRequestFromJSON(
  jsonString: string,
): SafeParseResult<UploadimageRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UploadimageRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UploadimageRequest' from JSON`,
  );
}
